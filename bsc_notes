Notizen:

1. Zunächst einmal stellte sich die Herausforderungen, alle Module eines Frameworks zu erfassen. Gängige Python-Methoden geben zwar die Submodule aus, aber um sämtliche Konfiguratonsoptionen zu finden, müssen die auch noch durchlaufen werden. Hier war die Schwierigkeit einen Überblick zu behalten, da manche Methoden direkt aurufbar waren bspw. mflow.get_tracking_uri, die jedoch über den Pfad.
2. Rausgefiltert werden dabei Methods mit single leading underscore _ (Name ist nur für interne Zwecke) und double leading underscore __ (wird genamemangled also textuell mit etwas anderem ersetzt) siehe https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name
3. Problematisch sind ebenfalls die Dopplungen von Namen, so befindet sich bspw.
	get_tracking_uri in mlflow und in mlflow.tracking
	log_artifact in mlflow und mlflow.tracking.MlflowClient
4. offen ist zudem wie die Config Optionen aus 3. in den echten Projekten dann auch getracket werden sollen. Möglichkeit: import mlflow und from mlflow Zeile untersuchen und dies zum Standard der Suche machen
5. Schwierigkeit zudem wie ich die Config-Options von normalen Methoden unterscheiden. list_artifacts ist vermutlich keine Configuration Option. 
6. Was ist zu dem mit den anderen dictioniairies etc.
7. Liste aller Methoden und Klassen mit for-Schleifen erwies sich als nicht zielführend, da Tiefe der for-Schleifen unbekannt -> Lösung: Baumstruktur mit Rekursion
8. Problem: Methoden können auf mehreren Wegen erreicht werden z.B. mlflow.h2o.mlflow.h2o.mlflow -> Gefahr von endlosen Schleifen / Rekursion
    Lösung: bei jedem Element wird geprüft ob es schon bereits im Baum vorhanden ist -> Verhindert Dopplungen, jedoch sind die Elemente dann an "falschen" Zweigen zugeordnet


types:
- module
- type
- method
- property
- builtin_function_or_method
- NoneType
- function
- str
- int
- string._TemplateMetaclass
- logging._StderrHandler
- bool
- logging.RootLogger
- urllib3.util.retry._RetryMeta
- typing._GenericAlias
- dict
- re.Pattern
- method_descriptor
- float
- getset_descriptor
- method_descriptor
- yaml.YAMLObjectMetaclass
- list

- Lösung:
    Doku der Packages werden auf der Website durchsucht. Dafür wird beautfilsoup als Scraper verwendet.
    Das ganze wird an PyTorch getestet. Dabei werden zunächst die ganzen Links der einzelnen Module gescrapt.
    In einer for-Schleife werden diese Links durchlaufen und in einem nested Dictionairy gespeichert mit dem Aufbau (module, (Function, Beschreibung))
    Vorteil ist das man auf Basis der Beschreibungen der Funktion sehr gut erkennen kann, welche Funktionen was machen. Beschreibungen die mit "Return" oder "" anfangen, kann man direkt aussortieren, Beschreibungen die mit Set anfangen sind potentielle Optionen.
    PRoblem: Die Beschreibungen werden tabellarisch in der Doku gespeichert. Leider sind nicht alle Seiten gleich aufgebaut, sodass bei einigen Modulen nichts gefunden wird oder die falsche Tabelle ausgelesen wird. Das muss händisch noch überprüft werden

- Neuer Ansatz: einfach dir() über Torch laufen lassen. Damit kann alles was über torch. aufgerufen wird angezeigt werden.


- Statische Code Analyse (https://luminousmen.com/post/python-static-analysis-tools)

- Zu Berücksichtigen:
    - Kommentare mit # oder "" ausschließen!
    - mehrere Zeilen zurückgeben, wenn über mehrere Zeilen verläuft
    - import Zeile besondere Aufmerksamkeit schenken. Mögliche Fälle: 1. import tensorflow 2. import tensorflow as tf 3. from tensorflow import xx
        1. Fall - Möglichkeiten:
            import tensorflow
            import tensorflow as tf
            import tensorflow, xx
            import tensorflow as tf, xx
            import xx, tensorflow
            import xx, tensorflow as tf
            import xx, tensorflow, yy
            import xx, tensorflow as tf, yy
            Lösung: unterteilen in mehrere Strings: import rauscutten
            UPDATE: 1. Fall: Falls Klassen definiert werden, an dieser Stelle direkt rausfiltern
            UPDATE: sklearn.base enthält as deshalb ändern
            evtl. Test mit allen möglichen Konstellationen schreiben?!

- UPDATE: nur noch Klassen rausfiltern. Klassen werden groß geschrieben, und von den Klassen nur noch die Parameter
        möglich Parameter kann man mit clf.__dict__ ausgeben, wenn man die Attribute, die mit _ enden noch löscht

- search_words ausdünnen, damit nicht jedes Mal eine spezifische Methode gesucht wird -> direkt eliminieren?

- Problem from sklearn import Class123 as c
    -> wie kann man nun nach c schauen?
Möglichkeiten wie Klassen auftachen:
    1. (Klasse,
    1. (Klasse)
    1. (Klasse
    1. (Klasse(
    1. (Klasse.
    2. ,Klasse)
    2. ,Klasse
    2. ,Klasse(
    2. ,Klasse,
    2. ,Klasse.
    3.  Klasse
    3.  Klasse(
    3.  Klasse,
    3.  Klasse)
    3.  Klasse.
    4. .Klasse(
    4. .Klasse)
    4. .Klasse,
    4. .Klasse
    4. .Klasse.


ungeklärte Probleme:
    - was wenn sich Wert einer Variable ändert bspw. am Anfang a = 5, am Ende a = 10, ausgegeben wird nur a = 10

zutun:
    - BinOp und UnaryOp immer checken!!!
    - Listen können unendlich tief sein -> auch das abdecken!

Fragen:
    - sklearn.cluster.AffinityPropagation() irrelevant?
    - ap = sklearn.cluster.AffinityPropagation() relevant?
    - linear_model.LinearRegression(2, 5) --> was davon relevant
    - regr = linear_model.LinearRegression(2, 5)
    - regr.fit(diabetes_X_train, diabetes_y_train)

- Ursprünglich alles als Dicitionary gespeichert, jedoch alphabetische Sortierung und keys einmalig, daher Lieber Liste
- Problem: unterscheiden zwischen strings und variable: plt.scatter(diabetes_X_test, diabetes_y_test, color=black)

Relevant:
    - linear_model.LinearRegression(6, 10)
    - regr = linear_model.LinearRegression(2, 5)
    - mdl.append(SVC(class_weight=None, probability=True))

irrelevant:
    - regr.fit(diabetes_X_train, diabetes_y_train)
    - regr2 = regr

Offen:
    - def func1():
        count = 100
        return count

      count = func1()
      linear_model.LinearRegression(count)
    - Welche Datenstruktur?
    - Wie berücksichtige ich die Struktur?
        - if/else, for
        - with
        - Funktionen
        - Klassen